\chapter{Base}
\section{Base.h}
\begin{enumerate}
\item void Sum(const VVReal \&, VReal*);
\end{enumerate}

\section{random.h}

\begin{enumerate}
\item void UniformSample(int t, VInt* v);
\\sample between 0 and size(v) uniformly t times.
\item double Sigmoid(double value);
\end{enumerate}

\section{stl\_util.h}
\begin{enumerate}
\item void Multiply(const VReal \&src, double m, VReal* des);
\item void Multiply(const VVReal \&src, double m, VVReal* des);
\item int DiffNum(const VInt \&lhs, const VInt \&rhs);
\\ the number of different value between lhs and rhs
\item double Max(const T \&data);
\item void Push(int num, const E \&e, C* des);
\end{enumerate}

\section{probability.h}
\begin{enumerate}
\item int SumTopN(const VInt \&src, int len);
\item bool NextMultiSeq(int num, VInt* des);
\\ 产生下一个多项式分布的序列
\item bool NextBinarySeq(VInt* des);
\\ 产生下一个二进制的序列
\end{enumerate}

\section{io\_util.h}
\begin{enumerate}
\item void ReadFileToStr(const Str \&file, Str* str);
\item void ReadFileToStr(const Str \&file, const Str \&del, VStr* data);
\item Str ReadFileToStr(const Str \&file);
\item void WriteStrToFile(const Str \&str, const Str \&file);
\item void ReadFile(const Str \&file, VInt* des);
\item void WriteFile(const Str \&file, const VInt \&data);
\end{enumerate}

\section{math\_util.h}
\begin{enumerate}
\item int Factorial(int n);
\end{enumerate}

\section{stat.h}
\begin{enumerate}
\item double LogSum(double log\_a, double log\_b);
\item double LogPartition(const VReal \&data);
\\输入data表示负能量值，返回对数配分函数。
很多时候势函数由于很大造成溢出，采用取对数的方法可以防止溢出。
\item double LogPartition(const VInt \&num, const VReal \&data);
\\带系数
\item double Quadratic(const V \&x, const V \&y, const M \&w);
\item double InnerProd(const V1 \&x, const V2 \&y);
\end{enumerate}

\chapter{ML}

\section{document.h}

\subsection{Corpus}
\begin{enumerate}
\item void NewLatent(VVInt* z) const;
\item void NewLatent(VVReal* z) const;
\item void NewLatent(VVVReal* z, int k) const;
\\该函数被gibbs.h使用。
\end{enumerate}

\section{eigen.h}

\begin{enumerate}
\item void ReadData(const Str $\&$path, TripleVec* vec);
\item pair$<$int, int$>$ Max(const TripleVec $\&$vec);
\item pair$<$int, int$>$ ReadData(const Str $\&$path, SpMat *mat);
\item void Sample(EVec *h);
\item void NormalRandom(EMat *mat);
\item void NormalRandom(EVec *vec);

\item 使用文件
\begin{enumerate}
\item ml/rbm/rbm.h
\end{enumerate}
\end{enumerate}

\section{util.h}
\begin{enumerate}
\item void Softmax(const VReal $\&$a, VReal *b);
\item int Sample(const VReal $\&$a);
\item int SoftmaxSample(const VReal $\&$a);
\item double NormalSample();

\item void RandomInit(int len, VReal* des);
\item void RandomInit(int row, int col, VVReal* des);
\item void RandomInit(int len1, int len2, int len3, VVVReal* des);

\item void RandomOrder(int len, int random\_num, VInt* des);

\item double Sum(const VReal $\&$v);
\item double Sum(const VVReal $\&$v);
\item double Sum(const VVVReal $\&$v);

\item double Var(const VReal $\&$v);
\item double Var(const VVReal $\&$v);
\item double Var(const VVVReal $\&$v);

\item double Mean(const VReal $\&$v);
\item double Mean(const VVReal $\&$v);
\item double Mean(const VVVReal $\&$v);
\item 使用文件
\begin{enumerate}
\item ml/rbm/rbm.h
\end{enumerate}
\end{enumerate}

\section{rbm}
\subsection{ais.h}
\begin{enumerate}
\item double LogPartition(int doc\_len, int word\_num, const RepSoftMax \&rep);
\end{enumerate}

\section{util.h}
